<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Canvas Studio — Image Editor</title>
<style>
  :root{
    --bg:#0f1223;
    --panel:#171a2e;
    --accent:#6c7bff;
    --accent-2:#3ad1c9;
    --text:#e8eaff;
    --muted:#a6a9cc;
    --danger:#ff6c8f;
    --ok:#47d16b;
    --shadow:0 10px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background: radial-gradient(1200px 700px at 30% 20%, #121532 0%, #0a0d1d 60%, #080a16 100%);
    color:var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", "Apple Color Emoji", "Segoe UI Emoji";
    overflow:hidden;
  }
  header{
    display:flex; align-items:center; gap:.75rem;
    padding: .75rem 1rem;
    backdrop-filter: blur(10px);
    background: linear-gradient(180deg, rgba(108,123,255,.18), rgba(108,123,255,0));
    border-bottom: 1px solid rgba(255,255,255,.06);
  }
  .logo{
    display:flex; align-items:center; gap:.5rem;
    font-weight:700; letter-spacing:.5px;
    filter: drop-shadow(0 5px 15px rgba(108,123,255,.25));
  }
  .logo .gem{
    width:28px; height:28px; border-radius:8px;
    background: conic-gradient(from 180deg, var(--accent), var(--accent-2), #9a7bff, var(--accent));
    box-shadow: inset 0 0 15px rgba(255,255,255,.2);
    animation: spin 8s linear infinite;
  }
  @keyframes spin {to{transform: rotate(1turn)}}
  .actions{
    margin-left:auto; display:flex; gap:.5rem;
  }
  .btn{
    appearance:none; border:none; cursor:pointer;
    padding:.5rem .75rem; border-radius:10px;
    color:var(--text);
    background: linear-gradient(180deg, #242949, #171a2e);
    box-shadow: var(--shadow);
    transition: all .2s cubic-bezier(0.4, 0, 0.2, 1);
    border:1px solid rgba(255,255,255,.08);
    position: relative;
    overflow: hidden;
  }
  .btn:hover{
    transform: translateY(-2px) scale(1.02);
    box-shadow: 0 15px 40px rgba(0,0,0,.4);
  }
  .btn:active{
    transform: translateY(0) scale(0.98);
    transition: all .1s ease;
  }
  .btn::before{
    content: '';
    position: absolute;
    top: 0; left: -100%;
    width: 100%; height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,.1), transparent);
    transition: left .6s ease;
  }
  .btn:hover::before{
    left: 100%;
  }
  .btn.primary{
    background: linear-gradient(180deg, #6c7bff, #4f5df0);
    color:#101225;
  }
  .btn.success{
    background: linear-gradient(180deg, #47d16b, #2fb156);
    color:#09110b;
  }
  .btn.danger{
    background: linear-gradient(180deg, #ff6c8f, #e44e73);
    color:#21080e;
  }
  .container{
    display:grid;
    grid-template-columns: 320px 1fr 320px;
    grid-template-rows: auto 1fr;
    height: calc(100% - 60px);
  }
  .sidebar, .rightbar{
    background: linear-gradient(180deg, #171a2e, #12152a);
    border-right:1px solid rgba(255,255,255,.06);
    box-shadow: var(--shadow);
    overflow:auto;
  }
  .rightbar{border-right:none; border-left:1px solid rgba(255,255,255,.06)}
  .panel{
    padding:1rem;
    border-bottom:1px solid rgba(255,255,255,.06);
  }
  .panel h3{
    margin:.25rem 0 1rem; font-size:1rem; font-weight:700; color:var(--muted);
    text-transform:uppercase; letter-spacing:.08em;
  }
  .tool-grid{
    display:grid; grid-template-columns: repeat(3, 1fr); gap:.6rem;
  }
  .tool{
    display:flex; align-items:center; justify-content:center; gap:.4rem;
    padding:.6rem .5rem; border-radius:10px; cursor:pointer;
    background: linear-gradient(180deg, #20264a, #141734);
    border:1px solid rgba(255,255,255,.08);
    transition: all .3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
  }
  .tool:hover{
    transform: translateY(-3px) scale(1.05);
    background: linear-gradient(180deg, #2a3055, #1a1e3f);
    box-shadow: 0 8px 25px rgba(0,0,0,.3);
  }
  .tool.active{
    outline: 2px solid var(--accent);
    box-shadow: 0 0 0 4px rgba(108,123,255,.15), 0 8px 25px rgba(108,123,255,.2);
    transform: translateY(-2px) scale(1.02);
    background: linear-gradient(180deg, #2d3358, #1d2142);
  }
  .tool.active::after{
    content: '';
    position: absolute;
    inset: -2px;
    border-radius: 12px;
    padding: 2px;
    background: linear-gradient(45deg, var(--accent), var(--accent-2));
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: xor;
    animation: borderGlow 2s ease-in-out infinite alternate;
  }
  @keyframes borderGlow{
    0%{opacity: .5}
    100%{opacity: 1}
  }
  .tool .icon{
    width:20px; height:20px; filter: drop-shadow(0 2px 6px rgba(0,0,0,.5));
  }
  .row{display:flex; gap:.75rem; align-items:center; margin-bottom:.75rem}
  input[type="color"]{
    width:36px; height:36px; padding:0; border:none; border-radius:8px; background:transparent;
    box-shadow: var(--shadow);
  }
  .range{
    width:100%;
    accent-color: var(--accent);
    transition: all .2s ease;
  }
  .range:hover{
    transform: scaleY(1.1);
  }
  .badge{
    padding:.25rem .5rem; border-radius:999px;
    background: linear-gradient(180deg, #242949, #171a2e);
    border:1px solid rgba(255,255,255,.08);
    font-size:.8rem; color:var(--muted);
  }
  .workspace{
    position:relative; background:
      radial-gradient(800px 300px at 70% 30%, rgba(58,209,201,.08), transparent 40%),
      radial-gradient(900px 600px at 30% 70%, rgba(108,123,255,.08), transparent 50%);
  }
  .canvas-wrap{
    position:relative; margin:1rem; border-radius:16px; overflow:hidden;
    background: repeating-conic-gradient(#eee 0% 25%, #ddd 0% 50%) 50%/24px 24px;
    border:1px solid rgba(255,255,255,.12);
    box-shadow: 0 30px 80px rgba(0,0,0,.5);
  }
  canvas{
    display:block; width:100%; height:100%;
    image-rendering: optimizeQuality;
    cursor: crosshair;
    transition: transform .3s cubic-bezier(0.4, 0, 0.2, 1), filter .2s ease;
  }
  .canvas-wrap{
    position:relative; margin:1rem; border-radius:16px; overflow:hidden;
    background: repeating-conic-gradient(#eee 0% 25%, #ddd 0% 50%) 50%/24px 24px;
    border:1px solid rgba(255,255,255,.12);
    box-shadow: 0 30px 80px rgba(0,0,0,.5);
    transition: box-shadow .3s ease;
  }
  .canvas-wrap:hover{
    box-shadow: 0 35px 90px rgba(0,0,0,.6);
  }
  .statusbar{
    position:absolute; left:0; right:0; bottom:0;
    display:flex; align-items:center; justify-content:space-between;
    background: linear-gradient(180deg, rgba(15,18,35,.2), rgba(7,8,18,.6));
    padding:.5rem .75rem; color:var(--muted);
    backdrop-filter: blur(6px);
  }
  .pill{
    padding:.25rem .5rem; border-radius:999px;
    background: linear-gradient(180deg, #1c2142, #141734);
    border:1px solid rgba(255,255,255,.06);
  }
  .filter-grid{
    display:grid; grid-template-columns: 1fr; gap:.75rem;
  }
  .group{padding:.5rem .75rem; border-radius:12px; background: rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.06)}
  .slider-row{display:grid; grid-template-columns: 110px 1fr 60px; gap:.5rem; align-items:center}
  .slider-row label{color:var(--muted)}
  .slider-row .val{color:var(--text); text-align:right}
  .floating-tip{
    /* floating-tip removed */
  }
  .kbd{padding:.05rem .35rem; border-radius:6px; background: rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.18)}
  .hidden{display:none}
  .footer{
    position:fixed; bottom:12px; left:12px; right:12px;
    display:flex; justify-content:center;
    pointer-events:none;
  }
  .toast{
    pointer-events:auto;
    padding:.6rem .9rem; border-radius:10px;
    background: linear-gradient(180deg, #1b2043, #111431);
    border:1px solid rgba(255,255,255,.08);
    box-shadow: var(--shadow);
    color:var(--muted);
    transform: translateY(30px); opacity:0;
    animation: toastIn .3s ease forwards;
  }
  @keyframes toastIn{
    0%{transform: translateY(30px) scale(0.9); opacity:0}
    50%{transform: translateY(-5px) scale(1.02); opacity:.8}
    100%{transform: translateY(0) scale(1); opacity:1}
  }
  .loading{
    position: relative;
    pointer-events: none;
  }
  .loading::after{
    content: '';
    position: absolute;
    inset: 0;
    background: rgba(108,123,255,.1);
    border-radius: inherit;
    animation: pulse 1.5s ease-in-out infinite;
  }
  @keyframes pulse{
    0%, 100%{opacity: .3}
    50%{opacity: .7}
  }
  .progress-bar{
    position: absolute;
    top: 0; left: 0;
    height: 2px;
    background: linear-gradient(90deg, var(--accent), var(--accent-2));
    border-radius: 1px;
    transform-origin: left;
    transform: scaleX(0);
    transition: transform .3s ease;
  }
  .filter-preview{
    transition: all .3s cubic-bezier(0.4, 0, 0.2, 1);
  }
  /* Uploaded image object overlay (draggable + resizable) */
  .img-object{
    position: absolute; top: 0; left: 0; touch-action: none;
    border: 1px dashed rgba(255,255,255,.12); border-radius:8px;
    background: transparent; box-shadow: 0 8px 30px rgba(0,0,0,.45);
    display: flex; align-items: center; justify-content: center;
    overflow: visible; user-select: none; z-index: 30;
  }
  .img-object img{ display:block; max-width:100%; max-height:100%; pointer-events:none; border-radius:6px }
  .img-controls{ position:absolute; top:6px; right:6px; display:flex; gap:6px; z-index:40 }
  .img-controls .btn{ padding:.25rem .45rem; font-size:.75rem }
  .img-object.active{ outline: 2px solid var(--accent); box-shadow: 0 20px 60px rgba(108,123,255,.18); }
  .canvas-wrap{ perspective: 1200px; }

  /* text overlay */
  .text-object{ position:absolute; display:flex; align-items:center; justify-content:center; padding:8px; min-width:80px; min-height:40px; z-index:30; cursor:move; }
  .text-content{ pointer-events:auto; outline:none; user-select:text; background:transparent; color:var(--text); font-weight:700; font-family: Segoe UI, sans-serif; font-size:36px; -webkit-background-clip:text; -webkit-text-fill-color:initial }
  .text-object .controls{ position:absolute; top:6px; right:6px; display:flex; gap:6px }
  .handle{ position:absolute; width:12px; height:12px; background:#fff; border-radius:2px; box-shadow:0 4px 12px rgba(0,0,0,.4); z-index:41 }
  .handle.br { right:-6px; bottom:-6px; cursor:se-resize }
  .handle.bl { left:-6px; bottom:-6px; cursor:sw-resize }
  .handle.tl { left:-6px; top:-6px; cursor:nw-resize }
  .handle.tr { right:-6px; top:-6px; cursor:ne-resize }
  /* context menu for image objects */
  .ctx-menu{
    position: absolute; z-index: 60; background: linear-gradient(180deg,#111428,#0f1226);
    border:1px solid rgba(255,255,255,.06); color:var(--text); border-radius:8px; padding:6px 0;
    box-shadow: 0 12px 40px rgba(0,0,0,.6); min-width:160px; font-size:13px;
  }
  .ctx-menu__item{ padding:8px 12px; cursor:pointer; white-space:nowrap }
  .ctx-menu__item:hover{ background: rgba(255,255,255,.03) }
  .ctx-menu__sep{ height:1px; background: rgba(255,255,255,.03); margin:6px 0 }
  /* Responsive / touch-friendly improvements */
  html{font-size:clamp(13px, 1.2vw + 10px, 18px)}
  .container{ transition: all .18s ease }
  /* Reduce hover-heavy effects on touch devices */
  @media (hover: none) {
    .tool:hover, .btn:hover, .img-object:hover{ transform: none }
  }

  /* Layout changes for narrow screens: stack panels and make canvas fluid */
  @media (max-width: 1000px){
    .container{ grid-template-columns: 1fr; grid-template-rows: auto 1fr auto; }
    .sidebar, .rightbar{ position:relative; width:100%; border-right:none; border-left:none; box-shadow:none; }
    .sidebar{ order:1 }
    .workspace{ order:2 }
    .rightbar{ order:3 }
    .canvas-wrap{ margin: .6rem; height: calc(60vh); border-radius:12px }
    header{ padding:.6rem; gap:.5rem }
    .actions{ gap:.4rem }
  }

  /* Mobile / small devices adjustments */
  @media (max-width: 600px){
    header{ flex-wrap:wrap; align-items:stretch }
    .logo{ flex:1 1 auto }
    .actions{ width:100%; display:flex; gap:.5rem; justify-content:space-between }
    .btn{ padding:.7rem .9rem; font-size:1rem; border-radius:12px }
    .tool{ padding:.7rem; gap:.6rem; font-size:0.95rem }
    .canvas-wrap{ height: calc(58vh); margin:.5rem; }
    canvas{ width:100% !important; height:100% !important }
    .img-controls .btn{ padding:.5rem .6rem; font-size:.9rem }
    .handle{ width:18px; height:18px }
    .text-object{ padding:10px; min-width:120px; min-height:44px }
    .text-content{ font-size:clamp(18px, 4vw, 42px) }
    .sidebar, .rightbar{ padding:.6rem }
  }

  /* Improve scrolling on mobile for side panels */
  .sidebar, .rightbar{ -webkit-overflow-scrolling: touch }

  /* Larger touch targets for overlay controls */
  .img-controls .btn, .img-controls button{ touch-action: manipulation; -webkit-tap-highlight-color: rgba(0,0,0,0.1) }

</style>
</head>
<body>
<header>
  <div class="logo">
    <div class="gem"></div>
    <div>Canvas Studio</div>
    <span class="badge">v1.0</span>
  </div>
  <div class="actions">
    <button class="btn" id="btnUpload">Upload</button>
    <button class="btn success" id="btnDownload">Download</button>
    <button class="btn" id="btnUndo">Undo</button>
    <button class="btn" id="btnRedo">Redo</button>
    <button class="btn danger" id="btnClear">Clear</button>
  </div>
</header>

<div class="container">
  <aside class="sidebar">
    <div class="panel">
      <h3>Tools</h3>
      <div class="tool-grid" id="toolGrid">
        <div class="tool active" data-tool="brush" title="Brush">
          <svg class="icon" viewBox="0 0 24 24"><path fill="#b5b8ff" d="M7,16c0,2,1,4,4,4s4-2,4-4"/></svg><span>Brush</span>
        </div>
        <div class="tool" data-tool="eraser" title="Eraser">
          <svg class="icon" viewBox="0 0 24 24"><path fill="#ffb5c7" d="M4 16l8-8 8 8-6 6H10z"/></svg><span>Eraser</span>
        </div>
        <div class="tool" data-tool="line" title="Line">
          <svg class="icon" viewBox="0 0 24 24"><path stroke="#a6f4e4" stroke-width="2" d="M4 20L20 4"/></svg><span>Line</span>
        </div>
        <div class="tool" data-tool="rect" title="Rectangle">
          <svg class="icon" viewBox="0 0 24 24"><rect x="5" y="6" width="14" height="12" fill="#a5b4fc"/></svg><span>Rect</span>
        </div>
        <div class="tool" data-tool="circle" title="Circle">
          <svg class="icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="7" fill="#fcd34d"/></svg><span>Circle</span>
        </div>
        <div class="tool" data-tool="polygon" title="Polygon">
          <svg class="icon" viewBox="0 0 24 24"><path fill="#86efac" d="M12 3l7 5-3 9H8L5 8z"/></svg><span>Poly</span>
        </div>
        <div class="tool" data-tool="text" title="Text">
          <svg class="icon" viewBox="0 0 24 24"><path fill="#f9a8d4" d="M4 6h16v2H13v10h-2V8H4z"/></svg><span>Text</span>
        </div>
        <div class="tool" data-tool="eyedropper" title="Eyedropper">
          <svg class="icon" viewBox="0 0 24 24"><path fill="#7dd3fc" d="M16 3l5 5-8 8-5 1 1-5z"/></svg><span>Pick</span>
        </div>
        <div class="tool" data-tool="select" title="Select area">
          <svg class="icon" viewBox="0 0 24 24"><rect x="5" y="5" width="14" height="14" stroke="#c4b5fd" fill="none"/></svg><span>Select</span>
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>Stroke and color</h3>
      <div class="row">
        <label class="badge">Color</label>
        <input type="color" id="colorPrimary" value="#6c7bff"/>
        <input type="color" id="colorSecondary" value="#000000"/>
      </div>
      <div class="row">
        <label class="badge">Size</label>
        <input class="range" type="range" id="size" min="1" max="100" value="16"/>
        <span id="sizeVal" class="badge">16 px</span>
      </div>
      <div class="row">
        <label class="badge">Opacity</label>
        <input class="range" type="range" id="opacity" min="0" max="1" step="0.01" value="1"/>
        <span id="opacityVal" class="badge">100%</span>
      </div>
      <div class="row">
        <label class="badge">Fill</label>
        <input type="checkbox" id="fillShape" checked/>
      </div>
      <div class="row">
        <label class="badge">Dashed</label>
        <input type="checkbox" id="dashedStroke"/>
      </div>
      <div class="row">
        <button class="btn" id="swapColors">Swap</button>
        <button class="btn" id="invertColors">Invert</button>
      </div>
    </div>

    <div class="panel">
      <h3>Image</h3>
      <div class="row">
        <label class="badge">Canvas</label>
        <input class="range" type="range" id="canvasW" min="300" max="2000" value="1280"/>
        <span class="badge" id="canvasWVal">1280</span>
      </div>
      <div class="row">
        <label class="badge">Height</label>
        <input class="range" type="range" id="canvasH" min="300" max="2000" value="720"/>
        <span class="badge" id="canvasHVal">720</span>
      </div>
      <div class="row">
        <button class="btn" id="resizeCanvas">Resize</button>
        <button class="btn" id="fitImage">Fit image</button>
      </div>
    </div>
  </aside>

  <main class="workspace">
    <div class="canvas-wrap" id="canvasWrap" style="width: 100%; height: calc(100% - 20px);">
      <canvas id="canvas" width="1280" height="720"></canvas>
      <div class="statusbar">
        <div class="pill">Tool: <span id="statusTool">Brush</span></div>
        <div class="pill">Zoom: <span id="statusZoom">100%</span></div>
        <div class="pill">Pos: <span id="statusPos">0, 0</span></div>
      </div>
    </div>
  </main>

  <aside class="rightbar">
    <div class="panel">
      <h3>Filters</h3>
      <div class="filter-grid">
        <div class="group slider-row">
          <label>Brightness</label>
          <input type="range" id="fBrightness" min="-100" max="100" value="0" class="range"/>
          <div class="val" id="valBrightness">0</div>
        </div>
        <div class="group slider-row">
          <label>Contrast</label>
          <input type="range" id="fContrast" min="-100" max="100" value="0" class="range"/>
          <div class="val" id="valContrast">0</div>
        </div>
        <div class="group slider-row">
          <label>Saturation</label>
          <input type="range" id="fSaturation" min="0" max="300" value="100" class="range"/>
          <div class="val" id="valSaturation">100</div>
        </div>
        <div class="group slider-row">
          <label>Hue</label>
          <input type="range" id="fHue" min="-180" max="180" value="0" class="range"/>
          <div class="val" id="valHue">0</div>
        </div>
        <div class="group slider-row">
          <label>Blur</label>
          <input type="range" id="fBlur" min="0" max="10" value="0" class="range"/>
          <div class="val" id="valBlur">0</div>
        </div>
        <div class="group slider-row">
          <label>Sharpness</label>
          <input type="range" id="fSharp" min="0" max="200" value="100" class="range"/>
          <div class="val" id="valSharp">100</div>
        </div>
        <div class="row">
          <button class="btn" id="applyFilters">Apply</button>
          <button class="btn" id="resetFilters">Reset</button>
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>Thumbnail Tools</h3>
      <div class="group">
        <div class="row">
          <button class="btn" id="preset16_9">16:9</button>
          <button class="btn" id="preset1_1">1:1</button>
          <button class="btn" id="preset1280">1280×720</button>
          <button class="btn" id="preset1920">1920×1080</button>
        </div>
        <div style="margin-top:.6rem">
          <label class="badge">Exposure</label>
          <input class="range" type="range" id="tExposure" min="-50" max="50" value="0"/>
          <div class="val" id="valExposure">0</div>
        </div>
        <div style="margin-top:.6rem">
          <label class="badge">Highlights</label>
          <input class="range" type="range" id="tHighlights" min="-50" max="50" value="0"/>
          <div class="val" id="valHighlights">0</div>
        </div>
        <div style="margin-top:.6rem">
          <label class="badge">Shadows</label>
          <input class="range" type="range" id="tShadows" min="-50" max="50" value="0"/>
          <div class="val" id="valShadows">0</div>
        </div>
        <div style="margin-top:.6rem">
          <label class="badge">Vibrance</label>
          <input class="range" type="range" id="tVibrance" min="-100" max="100" value="0"/>
          <div class="val" id="valVibrance">0</div>
        </div>
        <div style="margin-top:.6rem">
          <label class="badge">Sharpness</label>
          <input class="range" type="range" id="tSharp" min="0" max="200" value="100"/>
          <div class="val" id="valTSharp">100</div>
        </div>
        <div class="row" style="margin-top:.6rem">
          <button class="btn primary" id="autoEnhance">Auto Enhance</button>
          <button class="btn" id="applyOverlayToCanvas">Apply to canvas</button>
          <button class="btn" id="resetOverlayAdjust">Reset</button>
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>Export</h3>
      <div class="group">
        <div class="row">
          <label class="badge">Format</label>
          <select id="exportFormat" class="badge"><option value="png">PNG</option><option value="jpeg">JPEG</option></select>
        </div>
        <div class="row">
          <label class="badge">Scale</label>
          <select id="exportScale" class="badge"><option value="1">1×</option><option value="2">2×</option><option value="3">3×</option></select>
        </div>
        <div class="row">
          <label class="badge">Quality</label>
          <input type="range" id="exportQuality" class="range" min="0.1" max="1" step="0.05" value="0.92"/>
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>Text & 3D</h3>
      <div class="group">
        <div class="row">
          <button class="btn" id="addTextBtn">Add Text</button>
          <button class="btn" id="embedTextBtn">Embed Text</button>
          <button class="btn" id="removeTextBtn">Remove Text</button>
        </div>
        <div class="row">
          <label class="badge">Font</label>
          <select id="fontFamily" class="badge">
            <option>Segoe UI</option>
            <option>Arial</option>
            <option>Roboto</option>
            <option>Impact</option>
            <option>Times New Roman</option>
            <option>Georgia</option>
          </select>
        </div>
        <div class="row">
          <label class="badge">Size</label>
          <input class="range" id="fontSize" type="range" min="8" max="200" value="36"/>
          <span class="badge" id="fontSizeVal">36</span>
        </div>
        <div class="row">
          <label class="badge">Weight</label>
          <select id="fontWeight" class="badge"><option value="400">400</option><option value="600">600</option><option value="700" selected>700</option><option value="900">900</option></select>
          <label class="badge">Italic</label>
          <input type="checkbox" id="fontItalic" />
        </div>
        <div class="row">
          <label class="badge">Color</label>
          <input type="color" id="fontColor" value="#ffffff" />
          <label class="badge">Gradient</label>
          <input type="color" id="fontGradA" value="#ff7b7b" />
          <input type="color" id="fontGradB" value="#6c7bff" />
          <input type="checkbox" id="fontUseGradient" />
        </div>
        <div class="row">
          <label class="badge">Stroke</label>
          <input type="color" id="fontStrokeColor" value="#000000" />
          <input class="range" id="fontStrokeWidth" type="range" min="0" max="10" value="0"/>
        </div>
        <div class="row">
          <label class="badge">Shadow</label>
          <input type="color" id="fontShadowColor" value="#000000" />
          <input class="range" id="fontShadowBlur" type="range" min="0" max="60" value="8"/>
        </div>
        <div style="margin-top:.6rem">
          <label class="badge">Position Z (depth)</label>
          <input class="range" id="posZ" type="range" min="-800" max="800" value="0"/>
          <span class="badge" id="posZVal">0</span>
        </div>
        <div style="margin-top:.6rem">
          <label class="badge">Position X</label>
          <input class="range" id="posX" type="range" min="-2000" max="2000" value="0"/>
          <span class="badge" id="posXVal">0</span>
        </div>
        <div style="margin-top:.6rem">
          <label class="badge">Position Y</label>
          <input class="range" id="posY" type="range" min="-2000" max="2000" value="0"/>
          <span class="badge" id="posYVal">0</span>
        </div>
        <div style="margin-top:.6rem">
          <label class="badge">RotateX</label>
          <input class="range" id="rotX" type="range" min="-90" max="90" value="0"/>
        </div>
        <div style="margin-top:.6rem">
          <label class="badge">RotateY</label>
          <input class="range" id="rotY" type="range" min="-90" max="90" value="0"/>
        </div>
        <div style="margin-top:.6rem">
          <label class="badge">RotateZ</label>
          <input class="range" id="rotZ" type="range" min="-180" max="180" value="0"/>
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>Utilities</h3>
      <div class="row">
        <button class="btn" id="btnZoomIn">Zoom in</button>
        <button class="btn" id="btnZoomOut">Zoom out</button>
        <button class="btn" id="btnZoomReset">Reset</button>
      </div>
      <div class="row">
        <button class="btn" id="btnFlipH">Flip H</button>
        <button class="btn" id="btnFlipV">Flip V</button>
        <button class="btn" id="btnRotate">Rotate 90°</button>
      </div>
      <div class="row">
        <button class="btn" id="btnCrop">Crop</button>
        <button class="btn" id="btnSelectAll">Select all</button>
        <button class="btn" id="btnDeselect">Deselect</button>
      </div>
    </div>
  </aside>
</div>

<input type="file" id="fileInput" accept="image/*" class="hidden"/>

<div class="footer hidden" id="toastWrap">
  <div class="toast" id="toastMsg">Saved</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });

  // State
  let tool = 'brush';
  let drawing = false;
  let startX = 0, startY = 0;
  let lastX = 0, lastY = 0;
  let polygonPoints = [];
  let textInputEl = null;
  let zoom = 1;
  let selection = null;
  let history = [];
  let redoStack = [];
  let brushSize = 16;
  let opacity = 1;
  let primary = '#6c7bff';
  let secondary = '#000000';
  let fillShape = true;
  let dashedStroke = false;
  let imageFilters = {
    brightness:0, contrast:0, saturation:100, hue:0, blur:0, sharp:100
  };

  // Helpers
  function pushHistory() {
    try{
      const data = canvas.toDataURL('image/png');
      history.push(data);
      if(history.length>50) history.shift();
      redoStack = [];
    }catch(e){}
  }
  function restoreFromDataURL(url) {
    const img = new Image();
    img.onload = () => {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img,0,0);
    };
    img.src = url;
  }
  function showToast(msg){
    const wrap = document.getElementById('toastWrap');
    const toast = document.getElementById('toastMsg');
    toast.textContent = msg;
    wrap.classList.remove('hidden');
    setTimeout(()=>wrap.classList.add('hidden'), 2500);
  }
  function showLoading(element, duration = 1000){
    element.classList.add('loading');
    setTimeout(()=>element.classList.remove('loading'), duration);
  }
  function animateProgress(element, duration = 800){
    const bar = document.createElement('div');
    bar.className = 'progress-bar';
    element.style.position = 'relative';
    element.appendChild(bar);
    requestAnimationFrame(()=>{
      bar.style.transform = 'scaleX(1)';
      bar.style.transition = `transform ${duration}ms ease`;
    });
    setTimeout(()=>{
      if(bar.parentNode) bar.parentNode.removeChild(bar);
    }, duration + 100);
  }
  // --- Image overlay helpers: draggable + resizable uploaded images ---
  function createImageObject(src){
    const wrap = document.getElementById('canvasWrap');
    const rect = wrap.getBoundingClientRect();
    const wrapper = document.createElement('div');
    wrapper.className = 'img-object';
    wrapper.style.left = '50px'; wrapper.style.top = '50px';
    const img = document.createElement('img');
    img.src = src;
    wrapper.appendChild(img);

    // initial sizing (fit into canvas area)
    img.onload = ()=>{
      const maxW = rect.width * 0.7; const maxH = rect.height * 0.7;
      let w = img.naturalWidth, h = img.naturalHeight;
      const scale = Math.min(maxW / w, maxH / h, 1);
      w = w * scale; h = h * scale;
      wrapper.style.width = w + 'px'; wrapper.style.height = h + 'px';
      // center
      wrapper.style.left = Math.round((rect.width - w)/2) + 'px';
      wrapper.style.top = Math.round((rect.height - h)/2) + 'px';
      // store initial position/transform dataset values
      try{ wrapper.dataset.posX = Math.round(parseFloat(wrapper.style.left||0)); wrapper.dataset.posY = Math.round(parseFloat(wrapper.style.top||0)); }catch(e){}
    };

    // controls
    const ctrls = document.createElement('div'); ctrls.className='img-controls';
    const btnEmbed = document.createElement('button'); btnEmbed.className='btn'; btnEmbed.textContent='Embed';
    const btnRemove = document.createElement('button'); btnRemove.className='btn danger'; btnRemove.textContent='Remove';
    ctrls.appendChild(btnEmbed); ctrls.appendChild(btnRemove);
    wrapper.appendChild(ctrls);

    // resize handles
    ['tl','tr','bl','br'].forEach(cls=>{
      const h = document.createElement('div'); h.className = 'handle ' + cls; wrapper.appendChild(h);
    });

    // drag
    let dragging = false, dragStart = null, startRect = null;
    wrapper.addEventListener('pointerdown', (ev)=>{
      // select overlay when clicked
      selectOverlay(wrapper);
      if(ev.target.classList.contains('handle') || ev.target.closest('.img-controls')) return;
      ev.preventDefault(); wrapper.setPointerCapture(ev.pointerId);
      dragging = true;
      dragStart = {x: ev.clientX, y: ev.clientY};
      const r = wrapper.getBoundingClientRect(); startRect = {left: r.left - rect.left, top: r.top - rect.top, w: r.width, h: r.height};
    });
    window.addEventListener('pointermove', (ev)=>{
      if(!dragging) return;
      const dx = ev.clientX - dragStart.x, dy = ev.clientY - dragStart.y;
      wrapper.style.left = startRect.left + dx + 'px'; wrapper.style.top = startRect.top + dy + 'px';
      // update dataset so controls can reflect precise position
      try{ wrapper.dataset.posX = Math.round(parseFloat(wrapper.style.left || 0)); wrapper.dataset.posY = Math.round(parseFloat(wrapper.style.top || 0)); }catch(e){}
    });
    window.addEventListener('pointerup', (ev)=>{ if(dragging){ dragging=false; } });

    // resize logic
    wrapper.querySelectorAll('.handle').forEach(h=>{
      h.addEventListener('pointerdown', (ev)=>{
        ev.stopPropagation(); ev.preventDefault(); wrapper.setPointerCapture(ev.pointerId);
        const dir = h.classList.contains('tl') ? 'tl' : h.classList.contains('tr') ? 'tr' : h.classList.contains('bl') ? 'bl' : 'br';
        const pr = wrapper.getBoundingClientRect(); startRect = {left: pr.left - rect.left, top: pr.top - rect.top, w: pr.width, h: pr.height};
        const sx = ev.clientX, sy = ev.clientY;
        function onMove(mv){
          const dx = mv.clientX - sx, dy = mv.clientY - sy;
          let nw = startRect.w, nh = startRect.h, nl = startRect.left, nt = startRect.top;
          if(dir==='br'){ nw = Math.max(20, startRect.w + dx); nh = Math.max(20, startRect.h + dy); }
          if(dir==='bl'){ nw = Math.max(20, startRect.w - dx); nh = Math.max(20, startRect.h + dy); nl = startRect.left + dx; }
          if(dir==='tr'){ nw = Math.max(20, startRect.w + dx); nh = Math.max(20, startRect.h - dy); nt = startRect.top + dy; }
          if(dir==='tl'){ nw = Math.max(20, startRect.w - dx); nh = Math.max(20, startRect.h - dy); nl = startRect.left + dx; nt = startRect.top + dy; }
          wrapper.style.width = nw + 'px'; wrapper.style.height = nh + 'px'; wrapper.style.left = nl + 'px'; wrapper.style.top = nt + 'px';
        }
        function onUp(){ window.removeEventListener('pointermove', onMove); window.removeEventListener('pointerup', onUp); }
        window.addEventListener('pointermove', onMove); window.addEventListener('pointerup', onUp);
      });
    });

    // embed and remove
    btnEmbed.addEventListener('click', ()=>{ embedImageObject(wrapper); });
    btnRemove.addEventListener('click', ()=>{ wrapper.remove(); showToast('Image removed'); });

    // ensure transform state data
    wrapper.dataset.flipH = '0'; wrapper.dataset.flipV = '0'; wrapper.dataset.rotate = '0'; wrapper.dataset.gray = '0'; wrapper.dataset.sepia = '0';
    // 3D / transforms
    wrapper.dataset.posZ = '0'; wrapper.dataset.rotX = '0'; wrapper.dataset.rotY = '0'; wrapper.dataset.rotZ = '0';
    wrapper.dataset.posX = '0'; wrapper.dataset.posY = '0'; wrapper.dataset.sharpness = '100'; wrapper.dataset.sharp = '100';

    // context menu on right-click
    wrapper.addEventListener('contextmenu', (ev)=>{
      ev.preventDefault(); ev.stopPropagation();
      showContextMenuFor(wrapper, ev.clientX, ev.clientY);
    });

    document.getElementById('canvasWrap').appendChild(wrapper);
    return wrapper;
  }

  // Create editable text overlay that can be moved in X/Y and have Z/depth effect
  function createTextObject(text='New Text'){
    const wrap = document.getElementById('canvasWrap');
    const rect = wrap.getBoundingClientRect();
    const wrapper = document.createElement('div'); wrapper.className='text-object';
    wrapper.style.left = Math.round(rect.width/2 - 150) + 'px'; wrapper.style.top = Math.round(rect.height/2 - 40) + 'px';
    wrapper.style.width = 'auto'; wrapper.style.height = 'auto';
    wrapper.dataset.posZ = '0'; wrapper.dataset.rotX='0'; wrapper.dataset.rotY='0'; wrapper.dataset.rotZ='0';
    wrapper.dataset.fontFamily = 'Segoe UI'; wrapper.dataset.fontSize = '36'; wrapper.dataset.fontWeight='700'; wrapper.dataset.italic='0';
    wrapper.dataset.color = '#ffffff'; wrapper.dataset.gradA = '#ff7b7b'; wrapper.dataset.gradB = '#6c7bff'; wrapper.dataset.useGrad='0';
    wrapper.dataset.strokeColor='#000000'; wrapper.dataset.strokeWidth='0'; wrapper.dataset.shadowColor='#000000'; wrapper.dataset.shadowBlur='8';

    const txt = document.createElement('div'); txt.className='text-content'; txt.contentEditable = 'true'; txt.spellcheck = false; txt.innerText = text;
    wrapper.appendChild(txt);
    const controls = document.createElement('div'); controls.className='controls'; wrapper.appendChild(controls);

    // drag behavior (reuse pattern from image overlays)
    let dragging=false, dragStart=null, startRect=null;
    wrapper.addEventListener('pointerdown', (ev)=>{
      selectOverlay(wrapper);
      if(ev.target.closest('.controls')) return;
      // if user clicked directly on the text content, allow focus/edit instead of starting drag
      if(ev.target.closest('.text-content')){ return; }
      ev.preventDefault(); wrapper.setPointerCapture(ev.pointerId);
      dragging = true; dragStart = {x:ev.clientX,y:ev.clientY};
      const r = wrapper.getBoundingClientRect(); const cR = wrap.getBoundingClientRect(); startRect = {left: r.left - cR.left, top: r.top - cR.top};
    });
    window.addEventListener('pointermove', (ev)=>{ if(!dragging) return; const dx = ev.clientX - dragStart.x, dy = ev.clientY - dragStart.y; wrapper.style.left = startRect.left + dx + 'px'; wrapper.style.top = startRect.top + dy + 'px'; try{ wrapper.dataset.posX = Math.round(parseFloat(wrapper.style.left || 0)); wrapper.dataset.posY = Math.round(parseFloat(wrapper.style.top || 0)); }catch(e){} });
    window.addEventListener('pointerup', ()=>{ dragging=false; });

    // right-click context menu
    wrapper.addEventListener('contextmenu', (ev)=>{ ev.preventDefault(); ev.stopPropagation(); selectOverlay(wrapper); showContextMenuFor(wrapper, ev.clientX, ev.clientY); });

    // apply initial styles
    applyTextStyles(wrapper);
    wrap.appendChild(wrapper);
    // allow double-click to focus/edit text
    txt.addEventListener('dblclick', (e)=>{ e.stopPropagation(); txt.focus(); document.execCommand('selectAll', false, null); });
    return wrapper;
  }

  function applyTextStyles(wrapper){
    const txt = wrapper.querySelector('.text-content');
    if(!txt) return;
    const fam = wrapper.dataset.fontFamily || 'Segoe UI';
    const size = (wrapper.dataset.fontSize||36)+'px';
    const weight = wrapper.dataset.fontWeight||'700';
    const italic = wrapper.dataset.italic==='1' ? 'italic' : 'normal';
    txt.style.fontFamily = fam; txt.style.fontSize = size; txt.style.fontWeight = weight; txt.style.fontStyle = italic;
    // color or gradient
    if(wrapper.dataset.useGrad==='1'){
      const a = wrapper.dataset.gradA||'#fff', b = wrapper.dataset.gradB||'#000';
      txt.style.background = `linear-gradient(90deg, ${a}, ${b})`;
      txt.style['-webkit-background-clip'] = 'text'; txt.style['-webkit-text-fill-color']='transparent';
    } else {
      txt.style.background = 'none'; txt.style['-webkit-text-fill-color']=''; txt.style.color = wrapper.dataset.color || '#fff';
    }
    // stroke via text-shadow multiple passes approximation
    const sw = parseFloat(wrapper.dataset.strokeWidth||'0');
    if(sw>0){ txt.style.textShadow = `0 0 ${sw}px ${wrapper.dataset.strokeColor||'#000'}`; } else { txt.style.textShadow = `0 0 0 transparent`; }
    // shadow
    const sh = wrapper.dataset.shadowBlur||'0'; txt.style.filter = `drop-shadow(0px 2px ${sh}px ${wrapper.dataset.shadowColor||'#000'})`;
    // 3D transforms
    const z = parseFloat(wrapper.dataset.posZ||'0'); const rx = parseFloat(wrapper.dataset.rotX||'0'); const ry = parseFloat(wrapper.dataset.rotY||'0'); const rz = parseFloat(wrapper.dataset.rotZ||'0');
    // map Z to scale for parallax effect
    const scale = 1 + (z/1200);
    wrapper.style.transform = `translate3d(0,0,0) translateZ(${z}px) rotateX(${rx}deg) rotateY(${ry}deg) rotate(${rz}deg) scale(${scale})`;
    // position from dataset if present (keeps slider and drag in sync)
    if(typeof wrapper.dataset.posX !== 'undefined'){ wrapper.style.left = wrapper.dataset.posX + 'px'; document.getElementById('posXVal') && (document.getElementById('posXVal').textContent = wrapper.dataset.posX); }
    if(typeof wrapper.dataset.posY !== 'undefined'){ wrapper.style.top = wrapper.dataset.posY + 'px'; document.getElementById('posYVal') && (document.getElementById('posYVal').textContent = wrapper.dataset.posY); }
  }

  function embedTextObject(wrapper){
    const txt = wrapper.querySelector('.text-content');
    if(!txt) return;
    const cRect = canvas.getBoundingClientRect(); const wRect = wrapper.getBoundingClientRect();
    const dx = (wRect.left - cRect.left) * (canvas.width / cRect.width);
    const dy = (wRect.top - cRect.top) * (canvas.height / cRect.height);
    const dw = wRect.width * (canvas.width / cRect.width);
    const dh = wRect.height * (canvas.height / cRect.height);
    ctx.save();
    // build font
    const fs = parseInt(wrapper.dataset.fontSize||36,10); const wt = wrapper.dataset.fontWeight||'700'; const fam = wrapper.dataset.fontFamily||'Segoe UI';
    ctx.font = `${wt} ${fs}px ${fam}`;
    // handle rotation and z similarly to images
    const rot = parseFloat(wrapper.dataset.rotZ||0) * Math.PI/180;
    const flipH = wrapper.dataset.flipH==='1' ? -1 : 1;
    const flipV = wrapper.dataset.flipV==='1' ? -1 : 1;
    ctx.translate(dx + dw/2, dy + dh/2);
    ctx.rotate(rot);
    ctx.scale(flipH, flipV);
    // fill style: gradient or color
    if(wrapper.dataset.useGrad==='1'){
      const g = ctx.createLinearGradient(-dw/2,0,dw/2,0); g.addColorStop(0, wrapper.dataset.gradA || '#fff'); g.addColorStop(1, wrapper.dataset.gradB || '#000'); ctx.fillStyle = g;
    } else { ctx.fillStyle = wrapper.dataset.color || '#fff'; }
    // shadow
    if(wrapper.dataset.shadowColor){ ctx.shadowColor = wrapper.dataset.shadowColor; ctx.shadowBlur = parseFloat(wrapper.dataset.shadowBlur||0); }
    // stroke
    const strokeW = parseFloat(wrapper.dataset.strokeWidth||0);
    if(strokeW>0){ ctx.lineWidth = strokeW; ctx.strokeStyle = wrapper.dataset.strokeColor||'#000'; ctx.strokeText(txt.innerText, -dw/2 + 10, dh/2 - 10); }
    ctx.fillText(txt.innerText, -dw/2 + 10, dh/2 - 10);
    ctx.restore();
    pushHistory(); wrapper.remove(); showToast('Text embedded');
  }

  function embedImageObject(wrapper){
    const wrapRect = document.getElementById('canvasWrap').getBoundingClientRect();
    const cRect = canvas.getBoundingClientRect();
    const img = wrapper.querySelector('img');
    const r = wrapper.getBoundingClientRect();
    // compute position relative to canvas pixels
    const dx = (r.left - cRect.left) * (canvas.width / cRect.width);
    const dy = (r.top - cRect.top) * (canvas.height / cRect.height);
    const dw = r.width * (canvas.width / cRect.width);
    const dh = r.height * (canvas.height / cRect.height);
    // handle transforms (flip/rotate) and filters via canvas transforms and ctx.filter
    ctx.save();
    // apply filters if any (use CSS-like dataset values)
    const f = [];
    const exposure = parseFloat(wrapper.dataset.exposure||'0');
    const highlights = parseFloat(wrapper.dataset.highlights||'0');
    const vibrance = parseFloat(wrapper.dataset.vibrance||'0');
    if(!isNaN(exposure)) f.push(`brightness(${100+exposure}%)`);
    if(!isNaN(highlights)) f.push(`contrast(${100+highlights}%)`);
    if(!isNaN(vibrance)) f.push(`saturate(${100+vibrance}%)`);
    if(wrapper.dataset.gray==='1') f.push('grayscale(1)');
    if(wrapper.dataset.sepia==='1') f.push('sepia(1)');
    ctx.filter = f.join(' ') || 'none';

    // Draw with transform
    const rot = parseInt(wrapper.dataset.rotate||'0',10) || 0;
    const flipH = wrapper.dataset.flipH==='1' ? -1 : 1;
    const flipV = wrapper.dataset.flipV==='1' ? -1 : 1;
    // translate to center of target rect
    ctx.translate(dx + dw/2, dy + dh/2);
    ctx.rotate(rot * Math.PI/180);
    ctx.scale(flipH, flipV);
    ctx.drawImage(img, -dw/2, -dh/2, dw, dh);
    ctx.filter = 'none';
    ctx.restore();

    // apply sharpening if requested by overlay dataset (unsharp approximation)
    const sharp = parseFloat(wrapper.dataset.sharp||wrapper.dataset.sharpness||'100');
    if(!isNaN(sharp) && Math.abs(sharp - 100) > 1){
      const amount = (sharp - 100)/100;
      const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
      const data = imgData.data;
      const blurred = document.createElement('canvas'); blurred.width = canvas.width; blurred.height = canvas.height;
      const bctx = blurred.getContext('2d'); bctx.filter = 'blur(2px)'; bctx.drawImage(canvas,0,0);
      const bdata = bctx.getImageData(0,0,canvas.width,canvas.height).data;
      for(let i=0;i<data.length;i+=4){
        const hpR = data[i]-bdata[i];
        const hpG = data[i+1]-bdata[i+1];
        const hpB = data[i+2]-bdata[i+2];
        data[i]   = clamp(data[i]   + hpR*amount, 0, 255);
        data[i+1] = clamp(data[i+1] + hpG*amount, 0, 255);
        data[i+2] = clamp(data[i+2] + hpB*amount, 0, 255);
      }
      ctx.putImageData(imgData,0,0);
    }

    pushHistory(); wrapper.remove(); showToast('Image embedded into canvas');
  }

  // Apply CSS transforms (flip/rotate) based on dataset values
  function applyTransforms(wrapper){
    const img = wrapper.querySelector('img');
    const flipH = wrapper.dataset.flipH === '1';
    const flipV = wrapper.dataset.flipV === '1';
    const rot = parseInt(wrapper.dataset.rotate || '0', 10) || 0;
    const filters = [];
    if(wrapper.dataset.gray === '1') filters.push('grayscale(1)');
    if(wrapper.dataset.sepia === '1') filters.push('sepia(1)');
    // exposure/highlights/vibrance and temporary preview via CSS filters
    const exposure = parseFloat(wrapper.dataset.exposure||'0');
    const highlights = parseFloat(wrapper.dataset.highlights||'0');
    const vibrance = parseFloat(wrapper.dataset.vibrance||'0');
    if(!isNaN(exposure)) filters.unshift(`brightness(${100+exposure}%)`);
    if(!isNaN(highlights)) filters.push(`contrast(${100+highlights}%)`);
    if(!isNaN(vibrance)) filters.push(`saturate(${100+vibrance}%)`);
    img.style.filter = filters.join(' ');
    img.style.transform = `scaleX(${flipH?-1:1}) scaleY(${flipV?-1:1}) rotate(${rot}deg)`;
    // apply wrapper 3D transforms (translateZ, rotateX/Y and depth-scale)
    const z = parseFloat(wrapper.dataset.posZ||wrapper.dataset.z||'0');
    const rx = parseFloat(wrapper.dataset.rotX||'0');
    const ry = parseFloat(wrapper.dataset.rotY||'0');
    const rz = parseFloat(wrapper.dataset.rotZ||wrapper.dataset.rotate||'0');
    const scale = 1 + (z/1200);
    wrapper.style.transform = `translate3d(0,0,0) translateZ(${z}px) rotateX(${rx}deg) rotateY(${ry}deg) rotate(${rz}deg) scale(${scale})`;
  }

  // Context menu implementation
  let __ctxMenuEl = null;
  function hideContextMenu(){ if(__ctxMenuEl && __ctxMenuEl.parentNode) __ctxMenuEl.parentNode.removeChild(__ctxMenuEl); __ctxMenuEl = null; }
  function showContextMenuFor(wrapper, clientX, clientY){
    hideContextMenu();
    const wrap = document.getElementById('canvasWrap');
    const menu = document.createElement('div'); menu.className = 'ctx-menu';
    const makeItem = (txt, cb) => { const it = document.createElement('div'); it.className='ctx-menu__item'; it.textContent = txt; it.addEventListener('click', ()=>{ cb(); hideContextMenu(); }); menu.appendChild(it); };
    makeItem('Embed into canvas', ()=>embedImageObject(wrapper));
    makeItem('Duplicate', ()=>{
      const img = wrapper.querySelector('img');
      const r = wrapper.getBoundingClientRect(); const cw = wrap.getBoundingClientRect();
      const newEl = createImageObject(img.src);
      // set same size/pos, offset slightly
      newEl.style.width = wrapper.style.width; newEl.style.height = wrapper.style.height;
      newEl.style.left = (parseFloat(wrapper.style.left || 0) + 20) + 'px'; newEl.style.top = (parseFloat(wrapper.style.top || 0) + 20) + 'px';
      newEl.dataset.flipH = wrapper.dataset.flipH; newEl.dataset.flipV = wrapper.dataset.flipV; newEl.dataset.rotate = wrapper.dataset.rotate; newEl.dataset.gray = wrapper.dataset.gray; newEl.dataset.sepia = wrapper.dataset.sepia;
      applyTransforms(newEl);
    });
    makeItem('Remove', ()=>{ wrapper.remove(); showToast('Image removed'); });
    menu.appendChild(Object.assign(document.createElement('div'),{className:'ctx-menu__sep'}));
    makeItem('Bring to front', ()=>{
      let max = 30; document.querySelectorAll('.img-object').forEach(el=>{ max = Math.max(max, +(el.style.zIndex||30)); }); wrapper.style.zIndex = (max+1)+'';
    });
    makeItem('Send to back', ()=>{
      let min = 30; document.querySelectorAll('.img-object').forEach(el=>{ min = Math.min(min, +(el.style.zIndex||30)); }); wrapper.style.zIndex = (min-1)+'';
    });
    menu.appendChild(Object.assign(document.createElement('div'),{className:'ctx-menu__sep'}));
    makeItem('Flip Horizontal', ()=>{ wrapper.dataset.flipH = wrapper.dataset.flipH==='1' ? '0' : '1'; applyTransforms(wrapper); });
    makeItem('Flip Vertical', ()=>{ wrapper.dataset.flipV = wrapper.dataset.flipV==='1' ? '0' : '1'; applyTransforms(wrapper); });
    makeItem('Rotate 90°', ()=>{ wrapper.dataset.rotate = ((parseInt(wrapper.dataset.rotate||'0',10) + 90)%360)+''; applyTransforms(wrapper); });
    makeItem('Reset Transform', ()=>{ wrapper.dataset.flipH='0'; wrapper.dataset.flipV='0'; wrapper.dataset.rotate='0'; applyTransforms(wrapper); });
    menu.appendChild(Object.assign(document.createElement('div'),{className:'ctx-menu__sep'}));
    makeItem('Toggle Grayscale', ()=>{ wrapper.dataset.gray = wrapper.dataset.gray==='1' ? '0' : '1'; applyTransforms(wrapper); });
    makeItem('Toggle Sepia', ()=>{ wrapper.dataset.sepia = wrapper.dataset.sepia==='1' ? '0' : '1'; applyTransforms(wrapper); });
    makeItem('Reset Filters', ()=>{ wrapper.dataset.gray='0'; wrapper.dataset.sepia='0'; applyTransforms(wrapper); });

    __ctxMenuEl = menu;
    wrap.appendChild(menu);
    // position within wrap bounds
    const r = wrap.getBoundingClientRect();
    let left = clientX - r.left, top = clientY - r.top;
    menu.style.left = Math.max(6, Math.min(left, r.width - 180)) + 'px';
    menu.style.top = Math.max(6, Math.min(top, r.height - 10)) + 'px';
    // hide on outside click or escape
    setTimeout(()=>{ document.addEventListener('click', hideContextMenu, {once:true}); }, 10);
  }

  // Hide menu on ESC
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideContextMenu(); });

  // Selection handling for overlays
  let currentOverlay = null;
  function selectOverlay(wrapper){
    if(currentOverlay === wrapper) return;
    document.querySelectorAll('.img-object, .text-object').forEach(el=>el.classList.remove('active'));
    currentOverlay = wrapper;
    if(wrapper) wrapper.classList.add('active');
    // populate sliders/controls with dataset values (works for images and text overlays)
    if(wrapper){
      // filters
      document.getElementById('tExposure').value = wrapper.dataset.exposure || 0; document.getElementById('valExposure').textContent = wrapper.dataset.exposure||0;
      document.getElementById('tHighlights').value = wrapper.dataset.highlights || 0; document.getElementById('valHighlights').textContent = wrapper.dataset.highlights||0;
      document.getElementById('tShadows').value = wrapper.dataset.shadows || 0; document.getElementById('valShadows').textContent = wrapper.dataset.shadows||0;
      document.getElementById('tVibrance').value = wrapper.dataset.vibrance || 0; document.getElementById('valVibrance').textContent = wrapper.dataset.vibrance||0;
      document.getElementById('tSharp').value = wrapper.dataset.sharpness || wrapper.dataset.sharp || 100; document.getElementById('valTSharp').textContent = wrapper.dataset.sharpness || wrapper.dataset.sharp || 100;
      // transforms
      document.getElementById('posZ').value = wrapper.dataset.posZ || wrapper.dataset.z || 0; document.getElementById('posZVal').textContent = wrapper.dataset.posZ || wrapper.dataset.z || 0;
      document.getElementById('posX').value = wrapper.dataset.posX || parseInt(wrapper.style.left||0,10) || 0; document.getElementById('posXVal').textContent = wrapper.dataset.posX || parseInt(wrapper.style.left||0,10) || 0;
      document.getElementById('posY').value = wrapper.dataset.posY || parseInt(wrapper.style.top||0,10) || 0; document.getElementById('posYVal').textContent = wrapper.dataset.posY || parseInt(wrapper.style.top||0,10) || 0;
      document.getElementById('rotX').value = wrapper.dataset.rotX || 0; document.getElementById('rotY').value = wrapper.dataset.rotY || 0; document.getElementById('rotZ').value = wrapper.dataset.rotZ || wrapper.dataset.rotate || 0;
      // if it's a text overlay also populate font/style controls
      if(wrapper.classList.contains('text-object')){
        document.getElementById('fontFamily').value = wrapper.dataset.fontFamily || 'Segoe UI';
        document.getElementById('fontSize').value = wrapper.dataset.fontSize || 36; document.getElementById('fontSizeVal').textContent = wrapper.dataset.fontSize || 36;
        document.getElementById('fontWeight').value = wrapper.dataset.fontWeight || '700'; document.getElementById('fontItalic').checked = wrapper.dataset.italic==='1';
        document.getElementById('fontColor').value = wrapper.dataset.color || '#ffffff'; document.getElementById('fontUseGradient').checked = wrapper.dataset.useGrad==='1';
        document.getElementById('fontGradA').value = wrapper.dataset.gradA || '#ff7b7b'; document.getElementById('fontGradB').value = wrapper.dataset.gradB || '#6c7bff';
        document.getElementById('fontStrokeColor').value = wrapper.dataset.strokeColor || '#000000'; document.getElementById('fontStrokeWidth').value = wrapper.dataset.strokeWidth || 0;
        document.getElementById('fontShadowColor').value = wrapper.dataset.shadowColor || '#000000'; document.getElementById('fontShadowBlur').value = wrapper.dataset.shadowBlur || 8;
      }
    }
  }

  function deselectOverlay(){ selectOverlay(null); }

  // Overlay filter update helper
  function updateOverlayFilters(wrapper){
    if(!wrapper) return;
    // store values in dataset
    wrapper.dataset.exposure = document.getElementById('tExposure').value;
    wrapper.dataset.highlights = document.getElementById('tHighlights').value;
    wrapper.dataset.shadows = document.getElementById('tShadows').value;
    wrapper.dataset.vibrance = document.getElementById('tVibrance').value;
    wrapper.dataset.sharpness = document.getElementById('tSharp').value;
    applyTransforms(wrapper);
  }

  // wire up thumbnail tool UI
  ['tExposure','tHighlights','tShadows','tVibrance','tSharp'].forEach(id=>{
    const el = document.getElementById(id);
    if(!el) return;
    el.addEventListener('input',(e)=>{
      const v = e.target.value;
      if(id==='tExposure') document.getElementById('valExposure').textContent = v;
      if(id==='tHighlights') document.getElementById('valHighlights').textContent = v;
      if(id==='tShadows') document.getElementById('valShadows').textContent = v;
      if(id==='tVibrance') document.getElementById('valVibrance').textContent = v;
      if(id==='tSharp') document.getElementById('valTSharp').textContent = v;
      if(currentOverlay) updateOverlayFilters(currentOverlay);
    });
  });

  document.getElementById('resetOverlayAdjust').addEventListener('click',()=>{
    if(!currentOverlay) return; ['exposure','highlights','shadows','vibrance','sharpness'].forEach(k=>currentOverlay.dataset[k]='0'); currentOverlay.dataset.sharpness='100'; updateOverlayFilters(currentOverlay); showToast('Overlay adjustments reset');
  });

  document.getElementById('applyOverlayToCanvas').addEventListener('click',()=>{ if(currentOverlay) embedImageObject(currentOverlay); else showToast('No overlay selected'); });

  document.getElementById('autoEnhance').addEventListener('click', ()=>{
    if(!currentOverlay) return; // simple auto enhance: slight boost
    currentOverlay.dataset.exposure = 6; currentOverlay.dataset.highlights = 6; currentOverlay.dataset.vibrance = 8; currentOverlay.dataset.sharpness = 110; updateOverlayFilters(currentOverlay); showToast('Auto enhance applied');
  });

  // crop presets
  document.getElementById('preset16_9').addEventListener('click', ()=>{ canvas.width = 1280; canvas.height = 720; restoreFromDataURL(history[history.length-1] || canvas.toDataURL()); updateCanvasSizeDisplay(); showToast('Canvas set to 16:9'); });
  document.getElementById('preset1_1').addEventListener('click', ()=>{ canvas.width = 1080; canvas.height = 1080; restoreFromDataURL(history[history.length-1] || canvas.toDataURL()); updateCanvasSizeDisplay(); showToast('Canvas set to 1:1'); });
  document.getElementById('preset1280').addEventListener('click', ()=>{ canvas.width = 1280; canvas.height = 720; restoreFromDataURL(history[history.length-1] || canvas.toDataURL()); updateCanvasSizeDisplay(); showToast('Canvas set to 1280×720'); });
  document.getElementById('preset1920').addEventListener('click', ()=>{ canvas.width = 1920; canvas.height = 1080; restoreFromDataURL(history[history.length-1] || canvas.toDataURL()); updateCanvasSizeDisplay(); showToast('Canvas set to 1920×1080'); });

  // Export settings used by download
  function exportCanvas(){
    const fmt = document.getElementById('exportFormat').value || 'png';
    const scale = parseInt(document.getElementById('exportScale').value || '1',10) || 1;
    const quality = parseFloat(document.getElementById('exportQuality').value) || 0.92;
    const off = document.createElement('canvas'); off.width = Math.round(canvas.width * scale); off.height = Math.round(canvas.height * scale);
    const octx = off.getContext('2d'); octx.drawImage(canvas, 0, 0, off.width, off.height);
    if(fmt==='png') return off.toDataURL('image/png');
    return off.toDataURL('image/jpeg', quality);
  }

  // override download button to respect format/scale
  document.getElementById('btnDownload').addEventListener('click',()=>{
    const btn = document.getElementById('btnDownload');
    showLoading(btn, 600); animateProgress(btn, 500);
    setTimeout(()=>{
      const a = document.createElement('a'); a.href = exportCanvas(); a.download = `canvas-studio.${document.getElementById('exportFormat').value}`; a.click(); showToast('Export complete');
    }, 300);
  });

  // Text & 3D UI bindings
  document.getElementById('addTextBtn').addEventListener('click', ()=>{ const t = createTextObject('New Text'); selectOverlay(t); });
  document.getElementById('embedTextBtn').addEventListener('click', ()=>{ if(currentOverlay && currentOverlay.classList.contains('text-object')) embedTextObject(currentOverlay); else showToast('Select a text object'); });
  document.getElementById('removeTextBtn').addEventListener('click', ()=>{ if(currentOverlay){ currentOverlay.remove(); deselectOverlay(); showToast('Removed'); } else showToast('No text selected'); });

  ['fontFamily','fontSize','fontWeight','fontItalic','fontColor','fontUseGradient','fontGradA','fontGradB','fontStrokeColor','fontStrokeWidth','fontShadowColor','fontShadowBlur','posZ','posX','posY','rotX','rotY','rotZ'].forEach(id=>{
    const el = document.getElementById(id);
    if(!el) return;
    el.addEventListener('input', ()=>{
      if(!currentOverlay) return;
      if(id==='fontFamily') currentOverlay.dataset.fontFamily = el.value;
      if(id==='fontSize') { currentOverlay.dataset.fontSize = el.value; document.getElementById('fontSizeVal').textContent = el.value; }
      if(id==='fontWeight') currentOverlay.dataset.fontWeight = el.value;
      if(id==='fontItalic') currentOverlay.dataset.italic = el.checked ? '1' : '0';
      if(id==='fontColor') currentOverlay.dataset.color = el.value;
      if(id==='fontUseGradient') currentOverlay.dataset.useGrad = el.checked ? '1':'0';
      if(id==='fontGradA') currentOverlay.dataset.gradA = el.value;
      if(id==='fontGradB') currentOverlay.dataset.gradB = el.value;
      if(id==='fontStrokeColor') currentOverlay.dataset.strokeColor = el.value;
      if(id==='fontStrokeWidth') currentOverlay.dataset.strokeWidth = el.value;
      if(id==='fontShadowColor') currentOverlay.dataset.shadowColor = el.value;
      if(id==='fontShadowBlur') currentOverlay.dataset.shadowBlur = el.value;
      if(id==='posZ') { currentOverlay.dataset.posZ = el.value; document.getElementById('posZVal').textContent = el.value; }
      if(id==='posX') { currentOverlay.dataset.posX = el.value; document.getElementById('posXVal').textContent = el.value; try{ currentOverlay.style.left = el.value + 'px'; }catch(e){} }
      if(id==='posY') { currentOverlay.dataset.posY = el.value; document.getElementById('posYVal').textContent = el.value; try{ currentOverlay.style.top = el.value + 'px'; }catch(e){} }
      if(id==='rotX') currentOverlay.dataset.rotX = el.value;
      if(id==='rotY') currentOverlay.dataset.rotY = el.value;
      if(id==='rotZ') currentOverlay.dataset.rotZ = el.value;
      applyTextStyles(currentOverlay);
    });
  });
  function setStatus(){
    document.getElementById('statusTool').textContent = tool[0].toUpperCase()+tool.slice(1);
    document.getElementById('statusZoom').textContent = Math.round(zoom*100)+'%';
  }
  function canvasPoint(e){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width/rect.width);
    const y = (e.clientY - rect.top) * (canvas.height/rect.height);
    return {x, y};
  }

  // UI events
  document.getElementById('toolGrid').addEventListener('click', (e)=>{
    const btn = e.target.closest('.tool');
    if(!btn) return;
    [...document.querySelectorAll('.tool')].forEach(t=>t.classList.remove('active'));
    btn.classList.add('active');
    tool = btn.dataset.tool;
    setStatus();
    // Add ripple effect
    const ripple = document.createElement('div');
    ripple.style.cssText = `
      position: absolute; border-radius: 50%; background: rgba(255,255,255,.3);
      width: 20px; height: 20px; left: 50%; top: 50%;
      transform: translate(-50%, -50%) scale(0);
      animation: ripple .6s ease-out;
      pointer-events: none;
    `;
    btn.appendChild(ripple);
    setTimeout(()=>ripple.remove(), 600);
  });
  
  // Add ripple animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes ripple {
      to { transform: translate(-50%, -50%) scale(4); opacity: 0; }
    }
  `;
  document.head.appendChild(style);

  document.getElementById('size').addEventListener('input',(e)=>{
    brushSize = +e.target.value;
    document.getElementById('sizeVal').textContent = brushSize+' px';
  });
  document.getElementById('opacity').addEventListener('input',(e)=>{
    opacity = +e.target.value;
    document.getElementById('opacityVal').textContent = Math.round(opacity*100)+'%';
  });
  document.getElementById('colorPrimary').addEventListener('input',(e)=>{primary=e.target.value;});
  document.getElementById('colorSecondary').addEventListener('input',(e)=>{secondary=e.target.value;});
  document.getElementById('fillShape').addEventListener('change',(e)=>{fillShape=e.target.checked;});
  document.getElementById('dashedStroke').addEventListener('change',(e)=>{dashedStroke=e.target.checked;});
  document.getElementById('swapColors').addEventListener('click',()=>{
    const tmp = primary; primary = secondary; secondary = tmp;
    document.getElementById('colorPrimary').value = primary;
    document.getElementById('colorSecondary').value = secondary;
  });
  document.getElementById('invertColors').addEventListener('click',()=>{
    const inv = (hex)=>{
      const c = hex.replace('#','');
      const r = 255 - parseInt(c.slice(0,2),16);
      const g = 255 - parseInt(c.slice(2,4),16);
      const b = 255 - parseInt(c.slice(4,6),16);
      return '#'+[r,g,b].map(n=>n.toString(16).padStart(2,'0')).join('');
    };
    primary = inv(primary); secondary = inv(secondary);
    document.getElementById('colorPrimary').value = primary;
    document.getElementById('colorSecondary').value = secondary;
  });

  // Canvas interactions
  function beginStroke(x,y){
    drawing = true;
    startX = lastX = x;
    startY = lastY = y;
    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.setLineDash(dashedStroke ? [brushSize*0.8, brushSize*0.6] : []);
    ctx.lineWidth = brushSize;
    ctx.strokeStyle = tool==='eraser' ? '#000000' : primary;
    ctx.fillStyle = primary;
    if(tool==='brush' || tool==='eraser'){
      ctx.beginPath();
      ctx.moveTo(x,y);
    }
    if(tool==='polygon'){
      polygonPoints.push({x,y});
    }
  }
  function drawStroke(x,y,shiftKey=false,ctrlKey=false){
    if(!drawing) return;
    if(tool==='brush' || tool==='eraser'){
      ctx.lineTo(x,y);
      ctx.stroke();
    }else if(tool==='line'){
      ctx.restore(); // restore any previous state
      ctx.clearRect(0,0,canvas.width,canvas.height);
      restoreFromDataURL(history[history.length-1]); // show previous state
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.lineWidth = brushSize;
      ctx.strokeStyle = primary;
      ctx.setLineDash(dashedStroke ? [brushSize*0.8, brushSize*0.6] : []);
      const endX = shiftKey ? x : x, endY = shiftKey ? y : y;
      ctx.beginPath();
      ctx.moveTo(startX,startY);
      ctx.lineTo(endX,endY);
      ctx.stroke();
      ctx.restore();
    }else if(['rect','circle','select'].includes(tool)){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      restoreFromDataURL(history[history.length-1]);
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.lineWidth = brushSize;
      ctx.strokeStyle = primary;
      ctx.fillStyle = fillShape ? primary : 'transparent';
      ctx.setLineDash(dashedStroke ? [brushSize*0.8, brushSize*0.6] : []);
      const w = x - startX, h = y - startY;
      if(tool==='rect'){
        if(fillShape) ctx.fillRect(startX,startY,w,h);
        ctx.strokeRect(startX,startY,w,h);
      }else if(tool==='circle'){
        const rx = Math.abs(w), ry = Math.abs(h);
        const r = ctrlKey ? Math.min(rx, ry)/2 : Math.max(rx, ry)/2;
        const cx = startX + (w>0 ? r : -r), cy = startY + (h>0 ? r : -r);
        ctx.beginPath();
        ctx.arc(ctrlKey ? startX : cx, ctrlKey ? startY : cy, r, 0, Math.PI*2);
        if(fillShape) ctx.fill();
        ctx.stroke();
      }else if(tool==='select'){
        ctx.strokeStyle = '#7dd3fc';
        ctx.setLineDash([6,4]);
        ctx.strokeRect(startX,startY,w,h);
        selection = {x:startX, y:startY, w, h};
      }
      ctx.restore();
    }else if(tool==='eyedropper'){
      const px = ctx.getImageData(x,y,1,1).data;
      primary = '#'+[px[0],px[1],px[2]].map(n=>n.toString(16).padStart(2,'0')).join('');
      document.getElementById('colorPrimary').value = primary;
    }
    lastX = x; lastY = y;
  }
  function endStroke(x,y){
    if(!drawing) return;
    if(tool==='line'){
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.lineWidth = brushSize;
      ctx.strokeStyle = primary;
      ctx.setLineDash(dashedStroke ? [brushSize*0.8, brushSize*0.6] : []);
      ctx.beginPath();
      ctx.moveTo(startX,startY);
      ctx.lineTo(x,y);
      ctx.stroke();
      ctx.restore();
    }else if(tool==='rect' || tool==='circle' || tool==='select'){
      // already drawn during move; leave as-is
    }else if(tool==='polygon'){
      // polygon point added at begin; wait for double-click to close
    }else if(tool==='text'){
      // create overlay input
      createTextInput(x,y);
    }
    pushHistory();
    ctx.restore();
    drawing = false;
  }

  function createTextInput(x,y){
    if(textInputEl) return;
    textInputEl = document.createElement('input');
    textInputEl.type = 'text';
    textInputEl.placeholder = 'Type…';
    Object.assign(textInputEl.style,{
      position:'absolute', left: (x*(canvas.getBoundingClientRect().width/canvas.width))+'px',
      top:(y*(canvas.getBoundingClientRect().height/canvas.height))+'px',
      background:'rgba(255,255,255,.85)', color:'#111', padding:'6px 8px', borderRadius:'8px',
      border:'1px solid rgba(0,0,0,.2)', outline:'none', font:'600 16px/1.2 Segoe UI, sans-serif',
      boxShadow:'0 8px 22px rgba(0,0,0,.25)', zIndex: 10, minWidth:'140px'
    });
    document.getElementById('canvasWrap').appendChild(textInputEl);
    textInputEl.focus();
    textInputEl.addEventListener('keydown', (ev)=>{
      if(ev.key==='Enter'){
        const text = textInputEl.value;
        document.getElementById('canvasWrap').removeChild(textInputEl);
        textInputEl = null;
        ctx.save();
        ctx.globalAlpha = opacity;
        ctx.fillStyle = primary;
        ctx.font = `${Math.max(12, brushSize*1.2)}px Segoe UI, sans-serif`;
        ctx.fillText(text, x, y);
        ctx.restore();
        pushHistory();
      }else if(ev.key==='Escape'){
        document.getElementById('canvasWrap').removeChild(textInputEl);
        textInputEl = null;
      }
    });
  }

  // Mouse events
  canvas.addEventListener('mousedown', (e)=>{
    const {x,y} = canvasPoint(e);
    beginStroke(x,y);
  });
  canvas.addEventListener('mousemove', (e)=>{
    const {x,y} = canvasPoint(e);
    document.getElementById('statusPos').textContent = `${Math.round(x)}, ${Math.round(y)}`;
    if(drawing) drawStroke(x,y, e.shiftKey, e.ctrlKey);
  });
  canvas.addEventListener('mouseup', (e)=>{
    const {x,y} = canvasPoint(e);
    endStroke(x,y);
  });
  canvas.addEventListener('mouseleave', ()=>{
    if(drawing){ drawing=false; ctx.restore(); }
  });
  canvas.addEventListener('dblclick', ()=>{
    if(tool==='polygon' && polygonPoints.length>=3){
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.fillStyle = primary; ctx.strokeStyle = primary;
      ctx.lineWidth = brushSize;
      ctx.beginPath();
      ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
      for(let i=1;i<polygonPoints.length;i++) ctx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
      ctx.closePath();
      if(fillShape) ctx.fill();
      ctx.stroke();
      ctx.restore();
      pushHistory();
      polygonPoints = [];
    }
  });

  // Upload/Download with animations
  const fileInput = document.getElementById('fileInput');
  // Enhanced upload: device picker, URL, drag/drop, paste and recent storage
  function saveRecentImage(dataUrl){
    try{
      const key = 'recentImages:v1';
      const raw = localStorage.getItem(key);
      const arr = raw ? JSON.parse(raw) : [];
      // avoid duplicates
      if(arr[0] === dataUrl) return;
      arr.unshift(dataUrl);
      while(arr.length>10) arr.pop();
      localStorage.setItem(key, JSON.stringify(arr));
    }catch(e){ }
  }

  async function readFileAsDataURL(file){
    return await new Promise((res, rej)=>{
      const r = new FileReader(); r.onload = ()=>res(r.result); r.onerror = rej; r.readAsDataURL(file);
    });
  }

  async function handlePickedFile(file){
    if(!file) return;
    const btn = document.getElementById('btnUpload'); animateProgress(btn, 400); showLoading(btn, 500);
    try{
      const dataUrl = await readFileAsDataURL(file);
      createImageObject(dataUrl);
      saveRecentImage(dataUrl);
      showToast('Image ready to place — drag/resize and click Embed');
    }catch(e){ showToast('Failed to read file'); }
  }

  async function handleUrlUpload(){
    const url = prompt('Enter image URL (http/https):');
    if(!url) return;
    const btn = document.getElementById('btnUpload'); animateProgress(btn, 400); showLoading(btn, 800);
    try{
      // try fetch to convert to dataURL (avoids cross-origin tainting if allowed)
      const resp = await fetch(url, {mode:'cors'});
      if(!resp.ok) throw new Error('Fetch failed');
      const blob = await resp.blob();
      if(!blob.type.startsWith('image/')) throw new Error('Not an image');
      const dataUrl = await readFileAsDataURL(blob);
      createImageObject(dataUrl);
      saveRecentImage(dataUrl);
      showToast('Image loaded from web');
    }catch(err){
      // fallback: try to use URL directly (may taint canvas)
      createImageObject(url);
      showToast('Loaded URL — embedding may be blocked by CORS');
    }
  }

  function showRecentImagesMenu(clientX, clientY){
    const key = 'recentImages:v1'; const raw = localStorage.getItem(key); const arr = raw ? JSON.parse(raw) : [];
    if(!arr.length){ showToast('No recent images'); return; }
    const wrap = document.getElementById('canvasWrap');
    const menu = document.createElement('div'); menu.className = 'ctx-menu';
    arr.slice(0,10).forEach((d, idx)=>{
      const it = document.createElement('div'); it.className='ctx-menu__item';
      const img = document.createElement('img'); img.src = d; img.style.width='100%'; img.style.maxHeight='60px'; img.style.objectFit='cover'; img.style.borderRadius='6px';
      it.appendChild(img);
      it.addEventListener('click', ()=>{ createImageObject(d); hideContextMenu(); });
      menu.appendChild(it);
    });
    __ctxMenuEl && hideContextMenu(); __ctxMenuEl = menu; wrap.appendChild(menu);
    const r = wrap.getBoundingClientRect(); let left = (clientX||r.width/2) - r.left, top = (clientY||r.height/2) - r.top; menu.style.left = Math.max(6, Math.min(left, r.width - 200)) + 'px'; menu.style.top = Math.max(6, Math.min(top, r.height - 100)) + 'px';
    setTimeout(()=>{ document.addEventListener('click', hideContextMenu, {once:true}); }, 10);
  }

  function showUploadMenu(ev){
    // small contextual menu with options: device, URL, paste hint, recent
    const wrap = document.getElementById('canvasWrap'); hideContextMenu();
    const menu = document.createElement('div'); menu.className='ctx-menu';
    const mk = (txt, cb)=>{ const it = document.createElement('div'); it.className='ctx-menu__item'; it.textContent = txt; it.addEventListener('click', ()=>{ cb(); hideContextMenu(); }); menu.appendChild(it); };
    mk('From device...', ()=> fileInput.click());
    mk('From URL...', ()=> handleUrlUpload());
    mk('Paste image (Ctrl+V)', ()=>{ showToast('Press Ctrl+V to paste an image'); });
    mk('Recent uploads', ()=> showRecentImagesMenu(ev ? ev.clientX : null, ev ? ev.clientY : null));
    __ctxMenuEl = menu; wrap.appendChild(menu);
    const r = wrap.getBoundingClientRect(); let left = (ev ? ev.clientX : r.width/2) - r.left, top = (ev ? ev.clientY : r.height/2) - r.top; menu.style.left = Math.max(6, Math.min(left, r.width - 180)) + 'px'; menu.style.top = Math.max(6, Math.min(top, r.height - 10)) + 'px';
    setTimeout(()=>{ document.addEventListener('click', hideContextMenu, {once:true}); }, 10);
  }

  document.getElementById('btnUpload').addEventListener('click',(e)=>{ const btn=document.getElementById('btnUpload'); animateProgress(btn,300); showUploadMenu(e); });

  // file input change now uses FileReader to capture dataURL and save recent
  fileInput.addEventListener('change',(e)=>{
    const file = e.target.files[0]; if(!file) return; handlePickedFile(file);
    // reset input so same file can be picked again
    e.target.value = '';
  });

  // Paste handler
  document.addEventListener('paste', (ev)=>{
    const items = (ev.clipboardData && ev.clipboardData.items) ? ev.clipboardData.items : [];
    for(const it of items){
      if(it.type && it.type.indexOf('image')!==-1){
        const file = it.getAsFile(); handlePickedFile(file); ev.preventDefault(); return;
      }
    }
  });

  // Drag & drop on canvasWrap
  const canvasWrapEl = document.getElementById('canvasWrap');
  canvasWrapEl.addEventListener('dragover', (ev)=>{ ev.preventDefault(); ev.dataTransfer.dropEffect = 'copy'; });
  canvasWrapEl.addEventListener('drop', (ev)=>{
    ev.preventDefault(); const dt = ev.dataTransfer;
    if(dt.files && dt.files.length){ handlePickedFile(dt.files[0]); return; }
    const text = dt.getData('text/uri-list') || dt.getData('text/plain');
    if(text){ // try fetch the URL
      (async ()=>{ try{ const resp = await fetch(text); if(!resp.ok) throw new Error('fetch fail'); const blob = await resp.blob(); if(!blob.type.startsWith('image/')) throw new Error('not image'); const dataUrl = await readFileAsDataURL(blob); createImageObject(dataUrl); saveRecentImage(dataUrl); showToast('Image loaded from dropped URL'); }catch(e){ createImageObject(text); showToast('Dropped URL — may be blocked by CORS'); } })(); }
  });
  document.getElementById('btnDownload').addEventListener('click',()=>{
    const btn = document.getElementById('btnDownload');
    showLoading(btn, 1000);
    animateProgress(btn, 800);
    setTimeout(()=>{
      const a = document.createElement('a');
      a.href = canvas.toDataURL('image/png');
      a.download = 'canvas-studio.png';
      a.click();
      showToast('Image downloaded successfully!');
    }, 300);
  });

  // Undo/Redo/Clear with feedback
  document.getElementById('btnUndo').addEventListener('click',()=>{
    const btn = document.getElementById('btnUndo');
    if(history.length>1){
      animateProgress(btn, 400);
      const current = history.pop();
      redoStack.push(current);
      restoreFromDataURL(history[history.length-1]);
      showToast('Action undone');
    } else {
      showToast('Nothing to undo');
    }
  });
  document.getElementById('btnRedo').addEventListener('click',()=>{
    const btn = document.getElementById('btnRedo');
    if(redoStack.length){
      animateProgress(btn, 400);
      const next = redoStack.pop();
      history.push(next);
      restoreFromDataURL(next);
      showToast('Action redone');
    } else {
      showToast('Nothing to redo');
    }
  });
  document.getElementById('btnClear').addEventListener('click',()=>{
    const btn = document.getElementById('btnClear');
    showLoading(btn, 600);
    setTimeout(()=>{
      ctx.clearRect(0,0,canvas.width,canvas.height);
      pushHistory();
      showToast('Canvas cleared');
    }, 200);
  });

  // Canvas size
  function updateCanvasSizeDisplay(){
    document.getElementById('canvasWVal').textContent = canvas.width;
    document.getElementById('canvasHVal').textContent = canvas.height;
  }
  document.getElementById('canvasW').addEventListener('input',(e)=>{
    document.getElementById('canvasWVal').textContent = e.target.value;
  });
  document.getElementById('canvasH').addEventListener('input',(e)=>{
    document.getElementById('canvasHVal').textContent = e.target.value;
  });
  document.getElementById('resizeCanvas').addEventListener('click',()=>{
    const w = +document.getElementById('canvasW').value;
    const h = +document.getElementById('canvasH').value;
    // Save current image, then resize and redraw
    const data = canvas.toDataURL();
    canvas.width = w; canvas.height = h;
    const img = new Image();
    img.onload = ()=>{
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img,0,0);
      pushHistory();
      updateCanvasSizeDisplay();
      showToast('Canvas resized');
    };
    img.src = data;
  });
  document.getElementById('fitImage').addEventListener('click',()=>{
    // Resize canvas to fit currently visible image bounds
    const data = canvas.toDataURL();
    const img = new Image();
    img.onload = ()=>{
      canvas.width = img.width; canvas.height = img.height;
      ctx.drawImage(img,0,0);
      pushHistory();
      updateCanvasSizeDisplay();
      showToast('Fit to image');
    };
    img.src = data;
  });

  // Zoom with smooth animation
  document.getElementById('btnZoomIn').addEventListener('click',()=>{
    const btn = document.getElementById('btnZoomIn');
    animateProgress(btn, 300);
    zoom = Math.min(3, zoom + 0.1);
    canvas.style.transform = `scale(${zoom})`;
    canvas.style.transformOrigin = 'center center';
    setStatus();
    showToast(`Zoomed to ${Math.round(zoom*100)}%`);
  });
  document.getElementById('btnZoomOut').addEventListener('click',()=>{
    const btn = document.getElementById('btnZoomOut');
    animateProgress(btn, 300);
    zoom = Math.max(0.3, zoom - 0.1);
    canvas.style.transform = `scale(${zoom})`;
    canvas.style.transformOrigin = 'center center';
    setStatus();
    showToast(`Zoomed to ${Math.round(zoom*100)}%`);
  });
  document.getElementById('btnZoomReset').addEventListener('click',()=>{
    const btn = document.getElementById('btnZoomReset');
    animateProgress(btn, 400);
    zoom = 1;
    canvas.style.transform = `scale(${zoom})`;
    setStatus();
    showToast('Zoom reset');
  });

  // Filters with smooth preview
  function previewFilters(){
    const f = imageFilters;
    const css = [
      `brightness(${100+f.brightness}%)`,
      `contrast(${100+f.contrast}%)`,
      `saturate(${f.saturation}%)`,
      `hue-rotate(${f.hue}deg)`,
      `blur(${f.blur}px)`
    ].join(' ');
    canvas.classList.add('filter-preview');
    canvas.style.filter = css;
  }
  function applyFilters(){
    const btn = document.getElementById('applyFilters');
    showLoading(btn, 1500);
    animateProgress(btn, 1200);
    
    setTimeout(()=>{
      // Render current filter visually into pixels
      const f = imageFilters;
      const off = document.createElement('canvas');
      off.width = canvas.width; off.height = canvas.height;
      const octx = off.getContext('2d');
      octx.drawImage(canvas,0,0);
      const css = `brightness(${100+f.brightness}%) contrast(${100+f.contrast}%) saturate(${f.saturation}%) hue-rotate(${f.hue}deg) blur(${f.blur}px)`;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.filter = css;
      ctx.drawImage(off,0,0);
      ctx.filter = 'none';
      
      // Sharpness via unsharp mask approximation
      const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
      const data = imgData.data;
      const amount = (imageFilters.sharp - 100)/100;
      if(Math.abs(amount) > 0.01){
        const blurred = document.createElement('canvas');
        blurred.width = canvas.width; blurred.height = canvas.height;
        const bctx = blurred.getContext('2d');
        bctx.filter = 'blur(2px)';
        bctx.drawImage(canvas,0,0);
        const bdata = bctx.getImageData(0,0,canvas.width,canvas.height).data;
        for(let i=0;i<data.length;i+=4){
          const hpR = data[i]-bdata[i];
          const hpG = data[i+1]-bdata[i+1];
          const hpB = data[i+2]-bdata[i+2];
          data[i]   = clamp(data[i]   + hpR*amount, 0, 255);
          data[i+1] = clamp(data[i+1] + hpG*amount, 0, 255);
          data[i+2] = clamp(data[i+2] + hpB*amount, 0, 255);
        }
        ctx.putImageData(imgData,0,0);
      }
      canvas.style.filter = 'none';
      canvas.classList.remove('filter-preview');
      pushHistory();
      showToast('Filters applied successfully!');
    }, 300);
  }
  function clamp(v,min,max){return Math.max(min,Math.min(max,v));}

  ['fBrightness','fContrast','fSaturation','fHue','fBlur','fSharp'].forEach(id=>{
    document.getElementById(id).addEventListener('input',(e)=>{
      const v = +e.target.value;
      if(id==='fBrightness'){imageFilters.brightness=v; document.getElementById('valBrightness').textContent=v;}
      if(id==='fContrast'){imageFilters.contrast=v; document.getElementById('valContrast').textContent=v;}
      if(id==='fSaturation'){imageFilters.saturation=v; document.getElementById('valSaturation').textContent=v;}
      if(id==='fHue'){imageFilters.hue=v; document.getElementById('valHue').textContent=v;}
      if(id==='fBlur'){imageFilters.blur=v; document.getElementById('valBlur').textContent=v;}
      if(id==='fSharp'){imageFilters.sharp=v; document.getElementById('valSharp').textContent=v;}
      previewFilters();
    });
  });
  document.getElementById('applyFilters').addEventListener('click', applyFilters);
  document.getElementById('resetFilters').addEventListener('click',()=>{
    imageFilters = {brightness:0, contrast:0, saturation:100, hue:0, blur:0, sharp:100};
    ['valBrightness','valContrast','valSaturation','valHue','valBlur','valSharp'].forEach((id,i)=>{
      const vals=[0,0,100,0,0,100]; document.getElementById(id).textContent=vals[i];
    });
    ['fBrightness','fContrast','fSaturation','fHue','fBlur','fSharp'].forEach((id,i)=>{
      const vals=[0,0,100,0,0,100]; document.getElementById(id).value=vals[i];
    });
    canvas.style.filter = 'none';
    showToast('Filters reset');
  });

  // Utilities with animations
  document.getElementById('btnFlipH').addEventListener('click',()=>{
    const btn = document.getElementById('btnFlipH');
    showLoading(btn, 800);
    animateProgress(btn, 600);
    setTimeout(()=>{
      const off = document.createElement('canvas'); off.width=canvas.width; off.height=canvas.height;
      const octx = off.getContext('2d');
      octx.translate(off.width,0); octx.scale(-1,1);
      octx.drawImage(canvas,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(off,0,0);
      pushHistory(); showToast('Flipped horizontally');
    }, 200);
  });
  document.getElementById('btnFlipV').addEventListener('click',()=>{
    const btn = document.getElementById('btnFlipV');
    showLoading(btn, 800);
    animateProgress(btn, 600);
    setTimeout(()=>{
      const off = document.createElement('canvas'); off.width=canvas.width; off.height=canvas.height;
      const octx = off.getContext('2d');
      octx.translate(0,off.height); octx.scale(1,-1);
      octx.drawImage(canvas,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(off,0,0);
      pushHistory(); showToast('Flipped vertically');
    }, 200);
  });
  document.getElementById('btnRotate').addEventListener('click',()=>{
    const btn = document.getElementById('btnRotate');
    showLoading(btn, 1000);
    animateProgress(btn, 800);
    setTimeout(()=>{
      const off = document.createElement('canvas'); off.width=canvas.height; off.height=canvas.width;
      const octx = off.getContext('2d');
      octx.translate(off.width/2, off.height/2);
      octx.rotate(Math.PI/2);
      octx.drawImage(canvas, -canvas.width/2, -canvas.height/2);
      canvas.width = off.width; canvas.height = off.height;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(off,0,0);
      pushHistory(); updateCanvasSizeDisplay(); showToast('Rotated 90°');
    }, 300);
  });

  document.getElementById('btnCrop').addEventListener('click',()=>{
    if(!selection){ showToast('No selection'); return; }
    const {x,y,w,h} = selection;
    const rx = Math.min(x, x+w), ry = Math.min(y, y+h);
    const rw = Math.abs(w), rh = Math.abs(h);
    const imgData = ctx.getImageData(rx, ry, rw, rh);
    canvas.width = rw; canvas.height = rh;
    ctx.putImageData(imgData,0,0);
    selection = null;
    pushHistory(); updateCanvasSizeDisplay(); showToast('Cropped');
  });
  document.getElementById('btnSelectAll').addEventListener('click',()=>{
    selection = {x:0,y:0,w:canvas.width,h:canvas.height};
    showToast('Selected all');
  });
  document.getElementById('btnDeselect').addEventListener('click',()=>{
    selection = null; showToast('Deselected');
  });

  // Init
  function init(){
    // Create initial blank with checker bg preview already present
    ctx.clearRect(0,0,canvas.width,canvas.height);
    pushHistory();
    setStatus();
    updateCanvasSizeDisplay();
  }
  init();

  // Keyboard shortcuts
  window.addEventListener('keydown',(e)=>{
    if(e.ctrlKey && e.key.toLowerCase()==='z'){ e.preventDefault(); document.getElementById('btnUndo').click(); }
    if(e.ctrlKey && e.key.toLowerCase()==='y'){ e.preventDefault(); document.getElementById('btnRedo').click(); }
    if(e.key==='b'){ tool='brush'; setActiveTool('brush'); }
    if(e.key==='e'){ tool='eraser'; setActiveTool('eraser'); }
    if(e.key==='l'){ tool='line'; setActiveTool('line'); }
    if(e.key==='r'){ tool='rect'; setActiveTool('rect'); }
    if(e.key==='c'){ tool='circle'; setActiveTool('circle'); }
    if(e.key==='t'){ tool='text'; setActiveTool('text'); }
    if(e.key==='p'){ tool='polygon'; setActiveTool('polygon'); }
    if(e.key==='i'){ tool='eyedropper'; setActiveTool('eyedropper'); }
    if(e.key==='s'){ tool='select'; setActiveTool('select'); }
  });
  function setActiveTool(t){
    tool = t;
    [...document.querySelectorAll('.tool')].forEach(el=>{
      el.classList.toggle('active', el.dataset.tool===t);
    });
    setStatus();
  }
})();
</script>
</body>
</html>